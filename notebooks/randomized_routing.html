
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Randomized Routing &#8212; Probabilistic Algorithms and Data Structures</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Locality Sensitive Hashing (LSH)" href="lsh.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Probabilistic Algorithms and Data Structures</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Probabilistic Algorithms and Data Structures
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../content.html">
   Contents
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="intro_hashing.html">
     <strong>
      Ideas behind many probabilistic data structures
     </strong>
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="lsh.html">
     Locality Sensitive Hashing (LSH)
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     <strong>
      Randomized Routing
     </strong>
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/notebooks/randomized_routing.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/executablebooks/jupyter-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fnotebooks/randomized_routing.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/docs/notebooks/randomized_routing.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#grid-hypercube-architecture">
   Grid/Hypercube Architecture
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#routing-problem">
   Routing Problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bit-fixing-algorithm">
   Bit fixing Algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#permutation-routing">
   Permutation Routing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Randomized Routing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#solution-to-general-starts-dests">
     Solution to general (starts, dests):
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#general-insight">
   General Insight
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#code">
   Code
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simulation-code">
   Simulation Code
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generating-permutation">
     Generating Permutation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#wrapper-for-simluation-with-permutation-defined-above">
     Wrapper for simluation with permutation defined above
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#play-around-with-n">
   Play Around with n!
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#theory">
   Theory
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="randomized-routing">
<h1><strong>Randomized Routing</strong><a class="headerlink" href="#randomized-routing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Traditionally, algorithms have been designed to improve/bound the worst case performance on a problem. Such algorithms draw deep insights into the problem and carefully design and use datastructures. On the other hand, there are simpler algorithms which work very well on an average input while performing much worse on smaller number of bad inputs. QuickSort is a classic example of such an algorithm for sorting. While MergeSort has worst case complexity of <span class="math notranslate nohighlight">\(O(nlogn)\)</span>, QuickSort performs <span class="math notranslate nohighlight">\(O(nlogn)\)</span> on random input and can perform upto <span class="math notranslate nohighlight">\(O(n^2)\)</span> on <em>bad</em> inputs. On average inputs, QuickSort is <em>quicker</em> than MergeSort with lesser memory requirement, inplace operations and, hence, better cache utilization (<a class="reference external" href="https://www.geeksforgeeks.org/quicksort-better-mergesort/">see link</a>). Can the issue of <em>bad</em> inputs be solved to avoid worst case performance? As it turns out, the answer to <em>almost</em> solving the problem is Randomization. <em>Bad</em> inputs for QuickSort turn out to be ones when the elements are already ordered. So what if we randomly shuffle the array before running QuickSort? A simple trick like this would actually resolve the issue of bad inputs. In implementation, <a class="reference external" href="https://en.wikipedia.org/wiki/Quicksort">Randomized QuickSort</a> randomly partitions the array (by choosing random pivot) and has an expected complexity (over random pivots) of <span class="math notranslate nohighlight">\(O(nlogn)\)</span> for <strong>any input</strong>. Though worst case is still <span class="math notranslate nohighlight">\(O(n^2)\)</span>, note that for this algorithm, there are no <em>bad</em> inputs; only bad pivot choices.</p>
<p>As a general principle, we can utilize simpler algorithms which work well on an <em>average / random / uniform</em> inputs to solve the original problem with no restrictions on inputs. Randomized routing is another classic example. Here, we utilize an algorithm that is already good when the input is uniformly distributed. To make this algorithm work for generic input, all we require is clever randomization that tranforms the problem on any given input to (multiple) instances of the same problem with random input.</p>
<p>In this lecture, we study the problem of routing messages in distributed computation. In distributed computing, the idea is to distribute computation to different nodes on cluster and consolidate individual outputs to achieve original computation. In the process, messages have to be passed among nodes on the cluster. If the traffic on the cluster is large (i.e. there is congestion), there can be significant delays in message passing and will cause the overall computation to take longer. The task is to minimize the delays caused by congestion. We show how randomization helps in reducing the congestion delays. For simplicity of analysis, we assume Grid network architecture and permutation messaging paradigm of communication. However, the general usage of randomization in routing goes beyond these simplistic assumptions.</p>
</div>
<div class="section" id="grid-hypercube-architecture">
<h2>Grid/Hypercube Architecture<a class="headerlink" href="#grid-hypercube-architecture" title="Permalink to this headline">¶</a></h2>
<p>In very large clusters, every node cannot be connected to every other node. In such a case, nodes are connected to few other nodes and when a message has to be passed from one node to other, it has to determine a path to traverse. We consider a specific arrangement of nodes called grid model. Consider that we have <span class="math notranslate nohighlight">\(N=2^n\)</span> nodes in our graph. We identify each of the nodes with binary strings. We would need <span class="math notranslate nohighlight">\(log_2(N)=n\)</span> bits to identify N different nodes. In grid model, the two nodes are connected only if they have hamming distance exactly 1; i.e. their binary string ids have only one bit mismatch. So each node hash a out degree equal to number of bits in its representation , i.e. n. The message can be passed in any direction. Hence total degree is 2n. We can see that the total number of directed edges in the graph view of Grid model is nN . In figure 1 a grid model for N=8 is shown.</p>
<p><img alt="HyperCube Structure" src="https://drive.google.com/uc?id=1IrkAr6Go4VseRH3gYB7pYlYlzVx_uB7g" /></p>
</div>
<div class="section" id="routing-problem">
<h2>Routing Problem<a class="headerlink" href="#routing-problem" title="Permalink to this headline">¶</a></h2>
<p>In this problem, we assume that each link can carry only one message at a time. Hence whenever two or more messages arrive at a link, a queue is formed which is processed squentially, i.e., one at a time. This adds delay to the overall all-to-all communication step. The purpose of any good algorithm is to minimize the delay. This is a load balancing problem in disguise: we want to make sure no link receives overwhelmingly large load.</p>
<p>However network routing is extemetly memory constrained. Generally, any network message or packets on have few bits reserved for routing. Essentially, we cannot store any history of the packet traversal. We only have the destination information on each packet. As a result, it is impertative that the routing protocol is memoryless. More specifically, if a packet arrives at any node, just on the basis of its destination, we should be able to determine the next hop (or node) of this packet. This requirement rules out a lot of optimal algorithms. It turns out that there is a simple and clever strtegy, which is memoryless and ensures that no link is travered by the packet twice.</p>
</div>
<div class="section" id="bit-fixing-algorithm">
<h2>Bit fixing Algorithm<a class="headerlink" href="#bit-fixing-algorithm" title="Permalink to this headline">¶</a></h2>
<p><strong>One-One message passing</strong> : The algorithm can be described in one line: Given the destination of packet <em>dest</em> the currect location <em>curr</em>, send the packet to the node <em>next</em> with all bits same as <em>curr</em> except we flip the least significant bit of <em>curr</em> which is different from <em>dest</em>.  Before delving into the actual problem, its always advisable to look at simpler version of the problem to understand its properties. Lets look at the problem in which we want to pass a message from <em>start</em> to <em>dest</em> node. <em>start</em> and <em>dest</em> are bit string identifiers of the nodes respectively. We first present the algorithm and then discuss the properties of this algorithm.</p>
<p><strong>Bit Fixing Algorithm (BFA)</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Inputs</span><span class="p">:</span> <span class="n">start</span> <span class="p">,</span> <span class="n">destination</span>
<span class="n">Output</span> <span class="p">:</span> <span class="n">Path</span> <span class="kn">from</span> <span class="nn">start</span> <span class="n">to</span> <span class="n">destination</span>
<span class="n">Algorithm</span><span class="p">:</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">destination</span><span class="p">:</span>
        <span class="n">lbit</span> <span class="o">=</span> <span class="n">lowestMismatch</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="n">current</span>
        <span class="nb">next</span><span class="p">[</span><span class="n">lbit</span><span class="p">]</span> <span class="o">=</span> <span class="n">destination</span><span class="p">[</span><span class="n">lbit</span><span class="p">]</span>
        <span class="n">path</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">next</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="nb">next</span>
    <span class="n">path</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span>
        
</pre></div>
</div>
<p>A sample run of the algorithm is shown in the following figure, where the start=11011 and destination=10101. At each step the first mismatch in bits is underlined.</p>
<img src="https://drive.google.com/uc?id=1b9LDbzHUqMQ7AK-EwnCrg9n79d8O22dB" width="300" class="center">
<ul class="simple">
<li><p><strong>Bit Fixing Algorithm gives shortest path</strong> Path suggested by BFA always has length exactly equal to the number mismatches in the bit representation of <em>start</em> and <em>dest</em>. Also, we know that each edge joins two nodes that have exactly 1 bit different. Hence length of possible paths have to be greator than or equal to the number of mismatches in <em>start</em> and <em>dest</em> and BFA outputs the least of them</p></li>
<li><p><strong>Bit fixing Algorithm is memory-less</strong> In order to compute the link on which to send to message, at each step, the algorithm only requires destination address and its own current address (which it knows). So it satisfies the requirement of memory-less we defined above.</p></li>
<li><p><strong>Bit fixing Algorithm has optimal substructure property</strong> If you consider the any sub path (say <span class="math notranslate nohighlight">\(node_i\)</span> to <span class="math notranslate nohighlight">\(node_j\)</span>) of the path BFA outputs for (start, dest) is exactly the path it would output for <span class="math notranslate nohighlight">\(start=node_i\)</span> and <span class="math notranslate nohighlight">\(dest=node_j\)</span>. So in the BFA, there is exactly one path between any two nodes, irrespective of what the start, dest nodes are.</p></li>
<li><p><strong>Identity of path nodes</strong>  While going from start <span class="math notranslate nohighlight">\((S_1,S_2,\ldots,S_n)\)</span> to dest <span class="math notranslate nohighlight">\((D_1, D_2, \ldots D_n)\)</span>, every intermediate node has the bit string representation <span class="math notranslate nohighlight">\((D_1, D_2, \ldots D_i, S_{i+1}, \ldots S_n)\)</span> And with each progressing step the prefix of intermediate node matching with destination only grows longer. This also establishes that there are no cycles in the path.</p></li>
<li><p><strong>Path interaction</strong> The above properties also add restrictions to the interactions of two paths say (s1,d1) and (s2,d2) can have. Specifically, the paths can join each other at at most 1 node and continue on that path till they diverge. They cannot diverge and join each other again. We will use this property in our analysis for randomized routing. This is clearly shown in the following figure</p></li>
</ul>
<img src="https://drive.google.com/uc?id=1wJgBfqjDibm1t09vk2B-DWOqFIy8LVA5" width="800" class="center">
</div>
<div class="section" id="permutation-routing">
<h2>Permutation Routing<a class="headerlink" href="#permutation-routing" title="Permalink to this headline">¶</a></h2>
<p>Now lets look at all-to-all routing. This scheme is also called as permutation routing. For the sequence of start nodes <span class="math notranslate nohighlight">\(starts = [1 \ldots N]\)</span>, we can specify the destination nodes as a permutation of the start sequence <span class="math notranslate nohighlight">\(dests = Perm([1\ldots N])\)</span>. We have to pass the message from <span class="math notranslate nohighlight">\(starts[i]\)</span> to <span class="math notranslate nohighlight">\(dests[i]\)</span> for each i. The following theorem gives an idea of how well a deterministic algorithm can perform.</p>
<blockquote>
<div><p><strong>Theorem 1:</strong> Any (memory) oblivious deterministic algorithm for permutation routing with N machines and n (<span class="math notranslate nohighlight">\(\approx log N\)</span>) outward links require <span class="math notranslate nohighlight">\(\Omega(\sqrt{\frac{N}{n}})\)</span> steps</p>
</div></blockquote>
<p>This theorem basically requires us to look for solutions beyond the deterministic realm of algorithms. We will see that the results with the randomized routing will help us break this bound at least probabilistically.</p>
<div class="section" id="id1">
<h3>Randomized Routing<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>We will use bitfixing algorithm as a basic routing algorithm. If we were to run bitfixing algorithm on permutation routing problem , how would we expect the algorithm to fare? It is very obvious that an adversarial selection of permutation of starts can cause a lot of delays in routing. However, we would expect the delays to be bounded if the permutation was random. Before moving to the final algorithm, lets evaluate if our intuition is correct. The following theorem, in fact, confirms our conjecture that the basic algorithm for each pair of start and dest nodes already performs very well if the dest is a random permutation.</p>
<blockquote>
<div><p><strong>Theorem 2:</strong> If dests is random permutation of starts, then with probability <span class="math notranslate nohighlight">\((1 - (\frac{1}{2})^{1.5n})\)</span> message from starts[i] reaches the dests[i], for all i, in no more than 4n steps</p>
</div></blockquote>
</div>
<div class="section" id="solution-to-general-starts-dests">
<h3>Solution to general (starts, dests):<a class="headerlink" href="#solution-to-general-starts-dests" title="Permalink to this headline">¶</a></h3>
<p>So from the above theorem, it is clear that our intuition about random destinations is actually correct. We can use this to bound the time of any permutation routing problem. This can be done by adding a random intermediate destination between <em>starts</em> and <em>dests</em> locations.</p>
<blockquote>
<div><p>starts <span class="math notranslate nohighlight">\(\longrightarrow\)</span>  dests</p>
</div></blockquote>
<p>The above problem can be converted to the following and we use bitfixing algorithm for both the sections of the problem.</p>
<blockquote>
<div><p>starts <span class="math notranslate nohighlight">\(\longrightarrow\)</span> random <span class="math notranslate nohighlight">\(\longrightarrow\)</span> dests</p>
</div></blockquote>
<p>Using the theorem 2, we can say that with high probability the total time taken by the routing algorithm is bounded by 8n.</p>
</div>
</div>
<div class="section" id="general-insight">
<h2>General Insight<a class="headerlink" href="#general-insight" title="Permalink to this headline">¶</a></h2>
<p>It turns out that many algorithms, especially associated with graphs, have this property. When an algorithm is run on a uniformly sampled input (random), the algorithm has good running time with high probability. However, in general, there are many structured inputs, which can very well occur in practice; the performance is terrible. We can make such algorithms work for generic inputs by somehow converting the problem where we only run the algorithm over random inputs and still solve for any given (potentially structured and poorly performing) inputs. The conversion is dependent on the problem. For routing, by enforcing a random permutation of intermediate destinations, we were able to break the original problem with any given source-destination sequence to two problems where either the source or the destination is uniformly shuffled.</p>
<p>The classic example is Quicksort , which takes <span class="math notranslate nohighlight">\(O(n^2)\)</span> time in the worst case, but when randomized takes <span class="math notranslate nohighlight">\(O(n\log{n})\)</span> expected time and the running time depends only on the coin tosses , not on the input. Notice that randomized quick sort always leads to the correct output (Las Vegas Algorithms (<a class="reference external" href="https://en.wikipedia.org/wiki/Las_Vegas_algorithm">https://en.wikipedia.org/wiki/Las_Vegas_algorithm</a>))</p>
<p>A good lecture note with more such illustration can be found at
<a class="reference external" href="http://math.mit.edu/~goemans/notes-random.pdf">http://math.mit.edu/~goemans/notes-random.pdf</a></p>
</div>
<div class="section" id="code">
<h2>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h2>
<p>In this section, we give a basic delay simulator for routing over hypercube. We encourage the readers to play around with the value of n and different permutations to see how randomized routing successfully breaks the congestion. We also show one way to generate permutation that leads to congestion which is inspired from the constructive proof of Simplified Theorem 1 in Theory Section.</p>
</div>
<div class="section" id="simulation-code">
<h2>Simulation Code<a class="headerlink" href="#simulation-code" title="Permalink to this headline">¶</a></h2>
<p>each edge has a queue and at each time step only one message can cross over that edge.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simulation code</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">codearray</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">codenode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">codenode</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">start</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">+</span><span class="n">s</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="k">def</span> <span class="nf">linkid</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">dest</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span>

<span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">l</span> <span class="o">//</span> <span class="n">n</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">l</span> <span class="o">%</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">codenode</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">i</span>


<span class="k">def</span> <span class="nf">bit_fixing_links</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">codenode</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">codenode</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="c1">#print(d[:i]+s[i:], &quot;-&gt;&quot;, d[:i+1]+s[i+1:])</span>
        <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkid</span><span class="p">(</span><span class="n">d</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span><span class="n">d</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">links</span>


<span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">dests</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> <span class="c1">#starts = 0,1,..2^n-1</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">node_links</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># init node_links node-&gt; set of links</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">dests</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">node_links</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">bit_fixing_links</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> 
    <span class="c1"># init link_queues  link -&gt; waiting messages</span>
    <span class="n">link_queues</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">n</span><span class="p">):</span>
        <span class="n">link_queues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="c1"># put first step onto links</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_links</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">link_queues</span><span class="p">[</span><span class="n">node_links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">popleft</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">queues_empty</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">queues_empty</span><span class="p">:</span>
        <span class="n">queues_empty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># one message per link</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">link_queues</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">link_queues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="c1">#print(&quot;Link&quot;, decode(i, n), &quot;message&quot;, codenode(node, n), node)</span>
        <span class="c1"># process nodes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_links</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">link_queues</span><span class="p">[</span><span class="n">node_links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">popleft</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># see if queues are empty</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">link_queues</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">queues_empty</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">ct</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">link_queues</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1">#print(time, ct)</span>
    <span class="k">return</span> <span class="n">time</span>
</pre></div>
</div>
</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is formatted as code</span>
</pre></div>
</div>
<div class="section" id="generating-permutation">
<h3>Generating Permutation<a class="headerlink" href="#generating-permutation" title="Permalink to this headline">¶</a></h3>
<p>In order to generate a permutation that can cause good congestion. We map nodes of the form  0X to X0. where X is of length n/2 bits. Note that all the paths here have to pass through node labelled 0. For the rest of the nodes, we just map them to themselves.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generating cases for routing </span>

<span class="k">def</span> <span class="nf">get_random_perm</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># random</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">get_complementary_perm</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># complementary X -&gt; not(X)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">get_congested_perm</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c1"># creates paths that have to pass through node 0 exploiting bit fixing algorithm</span>
    <span class="c1">#assert(n%2==0)</span>
    <span class="n">nhalf1</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">nhalf2</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">Nhalf1</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nhalf1</span><span class="p">)</span>
    <span class="n">Nhalf2</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nhalf2</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nhalf1</span><span class="p">):</span>
      <span class="n">mapped_i</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">Nhalf2</span>
      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_i</span>
      <span class="n">a</span><span class="p">[</span><span class="n">mapped_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">a</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="wrapper-for-simluation-with-permutation-defined-above">
<h3>Wrapper for simluation with permutation defined above<a class="headerlink" href="#wrapper-for-simluation-with-permutation-defined-above" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># wrapper for comparison of routing directly vs using randomized intermediate step.</span>
<span class="k">def</span> <span class="nf">simulate_delay_congested_paths</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of Nodes:&quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">get_congested_perm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">get_random_perm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running Bitfixing direcly ...&quot;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;steps: &quot;</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running Bitfixing on starts-&gt;random&quot;</span><span class="p">)</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;steps: &quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running Bitfixing on random-&gt;dest&quot;</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;steps: &quot;</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------comparison ---------------------&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No. of steps with Direct:&quot;</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No. of steps with Randomized intermediate:&quot;</span><span class="p">,</span>  <span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">codearray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">codearray</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>


<span class="n">simulate_delay_congested_paths</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of Nodes: 4096
Running Bitfixing direcly ...
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>steps:  38
Running Bitfixing on starts-&gt;random
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>steps:  14
Running Bitfixing on random-&gt;dest
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>steps:  13
--------------comparison ---------------------
No. of steps with Direct: 38
No. of steps with Randomized intermediate: 27
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="play-around-with-n">
<h2>Play Around with n!<a class="headerlink" href="#play-around-with-n" title="Permalink to this headline">¶</a></h2>
<p>As expected, the direct routing time increases exponentially with increasing n whereas the randomized routing only increases linearly</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">ipywidgets</span> <span class="kn">import</span> <span class="n">interact</span><span class="p">,</span> <span class="n">interactive</span><span class="p">,</span> <span class="n">fixed</span><span class="p">,</span> <span class="n">interact_manual</span>
<span class="kn">import</span> <span class="nn">ipywidgets</span> <span class="k">as</span> <span class="nn">widgets</span>

<span class="n">interact_manual</span><span class="p">(</span><span class="n">simulate_delay_congested_paths</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">10</span><span class="p">));</span> <span class="c1"># colab fails &gt;=19 </span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "8ece17c2abf347f898c4dda966807724"}
</script></div>
</div>
</div>
<div class="section" id="theory">
<h2>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h2>
<p>Proof of Theorem 1</p>
<p>see theorem 2.2 in
<a class="reference external" href="https://cseweb.ucsd.edu/~slovett/teaching/SP15-CSE190/randomized_routing.pdf">uscd scribe on randomized routing </a></p>
<p>Proof of Theorem 2</p>
<blockquote>
<div><p><strong>Theorem 2:</strong> If dests is random permutation of starts, then with probability <span class="math notranslate nohighlight">\((1 - (\frac{1}{2})^{1.5n})\)</span> message from starts[i] reaches the dests[i], for all i, in no more than 4n steps</p>
</div></blockquote>
<p>We will use the following notation</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Time[message[i]]\)</span> : time taken by message from source i</p></li>
<li><p><span class="math notranslate nohighlight">\(Path(i)\)</span> : path taken by message from source i</p></li>
<li><p><span class="math notranslate nohighlight">\(delay(i)\)</span> : added delay due to congestion for message from source i</p></li>
<li><p><span class="math notranslate nohighlight">\(Intersection(i,j)\)</span> : proposition that path(i) and path(j) share an edge</p></li>
<li><p><span class="math notranslate nohighlight">\(Intersections(i,j)\)</span> : number of edges shared by path(i) and path(j)</p></li>
<li><p><span class="math notranslate nohighlight">\(T(e)\)</span> : number of nodes whose path share edge e</p></li>
<li><p><span class="math notranslate nohighlight">\(length(path)\)</span>: number of edges in a path</p></li>
</ul>
<p>We can write the time taken by packet i as following. The
$<span class="math notranslate nohighlight">\( Time[message[i]] = length(Path(i)) + delay(i) \leq n + delay(i)\)</span><span class="math notranslate nohighlight">\(
where delay is caused by different messages intersecting the path of this message from starts[i] to dests[i]. As defined in the problem above, the delay occurs only when two or more packets want to use the same link. Hence the paths of i and j must intersect for j to add to the delay for i. One important thing to note is that every packet can at most add a delay of 1 unit to the other packet. This is because a packet j can only \textit{join} the path of i at one single point. This follows from the optimal substructure property of BFA . Also, while they are sharing the path, a delay is added only at the start of the shared path.  So we can write the intersection as an indicator.
\)</span><span class="math notranslate nohighlight">\(
    delay_i \leq \sum_j \mathbb{I}(Intersection(i,j))
\)</span><span class="math notranslate nohighlight">\(
We can simplify the RHS of the above inequality by noting the following.
\)</span><span class="math notranslate nohighlight">\(
    \sum_j \mathbb{I}(Intersection(i,j)) \leq \sum_{j} Intersections(i,j)
\)</span>$
Where we replace the indicator with number of intersections. Also, we can write the RHS of the above inequality in terms of sum over edges as</p>
<div class="math notranslate nohighlight">
\[
    \sum_j \mathbb{I}(Intersection(i,j)) \leq \sum_{e \in Path(i)} T(e)
\]</div>
<p>T(e) is the total number of nodes sharing the edge e with node i. Note that R.H.S is an overestimate as each Indicator is replaced by the number of edges shared between the two paths.
Taking Expectation of <span class="math notranslate nohighlight">\(delay_i\)</span>, we have
$<span class="math notranslate nohighlight">\(
    E(delay_i) \leq \sum_{e \in Path(i)} E(T(e))
\)</span><span class="math notranslate nohighlight">\(
As, number of edges is bound by n,
\)</span><span class="math notranslate nohighlight">\(
    E(delay_i) \leq n E(T(e))
\)</span><span class="math notranslate nohighlight">\(
in order to find the E(T(e)), consider the following equation counting T(e)
\)</span><span class="math notranslate nohighlight">\(
    T(e) = \sum_{j \in [1,N]} (\mathbb{I}( e \in Path(j))
\)</span><span class="math notranslate nohighlight">\(
\)</span>
\sum_{e \in allEdges} T(e) = \sum_{e \in allEdges} \sum_{j \in [1,N]}  (\mathbb{I}( e \in Path(j)) $</p>
<p><span class="math notranslate nohighlight">\( \sum_{e \in allEdges} T(e)  = \sum_{j \in [1,N]} \sum_{e \in allEdges}  (\mathbb{I}( e \in Path(j))\)</span></p>
<p><span class="math notranslate nohighlight">\( \sum_{e \in allEdges} T(e)  = \sum_{j \in [1,N]} (length(Path(j))) \)</span></p>
<p>Taking expectation
$<span class="math notranslate nohighlight">\( E(\sum_{e \in allEdges} T(e)) = \sum_{j \in [1,N]} E(length(Path(j)))\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\( Nn E(T(e)) = N \frac{n}{2} \)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\( E(T(e)) = \frac{1}{2}\)</span>$</p>
<p>Hence expectation of the delay is
$<span class="math notranslate nohighlight">\( E(delay_i) \leq \frac{n}{2}\)</span>$</p>
<p>As <span class="math notranslate nohighlight">\(delay_i\)</span> is a sum of independent bernoulli variables, we can use chernoff bounds to obtain the tail bound.</p>
<div class="math notranslate nohighlight">
\[
    P( delay_i \geq (1+\delta) \mu)) \leq e^{-(\frac{\delta^2\mu}{2+\delta})}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu \leq \frac{n}{2} \)</span>
Now we want to choose <span class="math notranslate nohighlight">\(\delta\)</span> in a way that rest of the analysis follows, specifically, we want the probability on the right to be small enough to give a good tail bound after we apply the union bound. Lets aim for now to keep the probability on right bounded by <span class="math notranslate nohighlight">\(\frac{1}{N^{2.5}}\)</span>
$<span class="math notranslate nohighlight">\( e^{-(\frac{\delta^2\mu}{2+\delta})} \leq \frac{1}{N^{2.5}} \)</span>$</p>
<div class="math notranslate nohighlight">
\[ -log_2(e)(\frac{\delta^2\mu}{2+\delta}) \leq - 2.5 log_2(N) \]</div>
<div class="math notranslate nohighlight">
\[ log_2(e)(\frac{\delta^2\mu}{2+\delta}) \geq 2.5 n \geq 2.5 * 2 \mu \]</div>
<div class="math notranslate nohighlight">
\[ log_2(e)(\frac{\delta^2}{2+\delta}) \geq 5 \]</div>
<p>By substituting <span class="math notranslate nohighlight">\(\delta = 5\)</span> we can see that the equation above is satisfied.
Hence we have,
$<span class="math notranslate nohighlight">\( P( delay_i \geq 6 \mu)) \leq \frac{1}{N^{2.5}} \)</span>$</p>
<div class="math notranslate nohighlight">
\[ P( delay_i \geq 3n)) \leq \frac{1}{N^{2.5}} \]</div>
<p>Applying union bound over all the nodes, we get
$<span class="math notranslate nohighlight">\( P( \exists i \quad delay_i \geq 3n)) \leq \frac{1}{N^{1.5}} \)</span>$</p>
<p>Hence the total time according to equation 1, is bounded by
$<span class="math notranslate nohighlight">\( P( TotalTime \geq 4n)) \leq \frac{1}{N^{1.5}} \)</span><span class="math notranslate nohighlight">\(
Hence with probability \)</span>1 - \frac{1}{N^{1.5}} ( = 1 - (\frac{1}{2})^{1.5n})$, the total time taken is no more than 4n \
That completes our proof.</p>
</div>
</div>


<script type="application/vnd.jupyter.widget-state+json">
{"state": {"f0f4566eedde4984b8519b27f1994a66": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "dfcb0b0b41c148e5ad15f4e5e83427ec": {"model_name": "SliderStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "SliderStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": "", "handle_color": null}}, "9d1dae59c4fe4718a57e59731ada49c7": {"model_name": "IntSliderModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "IntSliderModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "IntSliderView", "continuous_update": true, "description": "n", "description_tooltip": null, "disabled": false, "layout": "IPY_MODEL_f0f4566eedde4984b8519b27f1994a66", "max": 18, "min": 0, "orientation": "horizontal", "readout": true, "readout_format": "d", "step": 1, "style": "IPY_MODEL_dfcb0b0b41c148e5ad15f4e5e83427ec", "value": 10}}, "6b0b785da81e43ca95ac9eb6a58485af": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "8ece17c2abf347f898c4dda966807724": {"model_name": "VBoxModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": ["widget-interact"], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "VBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "VBoxView", "box_style": "", "children": ["IPY_MODEL_9d1dae59c4fe4718a57e59731ada49c7", "IPY_MODEL_0171ac99b5c94196b2c2ad723588a52f", "IPY_MODEL_c4301c524cb94fe1b7a5fef884981dc3"], "layout": "IPY_MODEL_6b0b785da81e43ca95ac9eb6a58485af"}}, "615695ed48dd4198ad43106b61c61728": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "a310ff2c3d0a48d387864aee15c2e369": {"model_name": "ButtonStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ButtonStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "button_color": null, "font_weight": ""}}, "0171ac99b5c94196b2c2ad723588a52f": {"model_name": "ButtonModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ButtonModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ButtonView", "button_style": "", "description": "Run Interact", "disabled": false, "icon": "", "layout": "IPY_MODEL_615695ed48dd4198ad43106b61c61728", "style": "IPY_MODEL_a310ff2c3d0a48d387864aee15c2e369", "tooltip": ""}}, "ef2e32d3a7fc48b6b257d02a3c32f940": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "c4301c524cb94fe1b7a5fef884981dc3": {"model_name": "OutputModel", "model_module": "@jupyter-widgets/output", "model_module_version": "1.0.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/output", "_model_module_version": "1.0.0", "_model_name": "OutputModel", "_view_count": null, "_view_module": "@jupyter-widgets/output", "_view_module_version": "1.0.0", "_view_name": "OutputView", "layout": "IPY_MODEL_ef2e32d3a7fc48b6b257d02a3c32f940", "msg_id": "", "outputs": []}}}, "version_major": 2, "version_minor": 0}
</script>


    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="lsh.html" title="previous page">Locality Sensitive Hashing (LSH)</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Aditya Desai, Anshumali Shrivastava<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>